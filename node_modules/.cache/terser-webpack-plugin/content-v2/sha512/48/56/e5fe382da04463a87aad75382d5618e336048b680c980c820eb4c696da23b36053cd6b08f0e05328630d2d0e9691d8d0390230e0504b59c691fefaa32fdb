{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{404:function(t,e,s){\"use strict\";s.r(e);var a=s(25),l=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"life-cycle\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#life-cycle\"}},[t._v(\"#\")]),t._v(\" Life Cycle\")]),t._v(\" \"),s(\"h2\",{attrs:{id:\"four-steps-of-life-cycle\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#four-steps-of-life-cycle\"}},[t._v(\"#\")]),t._v(\" Four Steps of Life Cycle\")]),t._v(\" \"),s(\"ol\",[s(\"li\",[t._v(\"初始化阶段\")])]),t._v(\" \"),s(\"p\",[t._v(\"两部分：第一部分new Vue( )，创建一个vue实例。第二部分初始化实例的一些事件，属性。响应式数据等。初始化生命周期，初始化事件（初始化事件函数initEvents实际上初始化的是父组件在模板中使用v-on或@注册的监听子组件内触发的事件。），初始化函数，初始化响应式数据（初始化props，初始化methods，初始化data，初始化computed，初始化watch。这5个选项中的所有属性最终都会被绑定到实例上，这也就是我们为什么可以使用this.xxx来访问任意属性。）\")]),t._v(\" \"),s(\"ol\",{attrs:{start:\"2\"}},[s(\"li\",[t._v(\"模板编译阶段\")])]),t._v(\" \"),s(\"p\",[t._v(\"在实际开发中，我们需要借助像webpack的vue-loader这类工具进行编译，将Vue对模板的编译阶段合并到webpack的构建流程中，这样不仅减少了生产环境代码的体积，也大大提高了运行时的性能，一举两得。\\nVue源码构建有两种版本：完整版本和只包含运行版本。两种版本的$mount方法在于是否进行了模板编译。在只包含运行版本时，$mount方法中获取到的DOM元素后直接进入挂载阶段，而完整版本$mount方法是先将模板进行编译，然后回过头调用只包含运行时版本的$mount方法进入挂载。\")]),t._v(\" \"),s(\"ol\",{attrs:{start:\"3\"}},[s(\"li\",[t._v(\"挂载阶段\")])]),t._v(\" \"),s(\"p\",[t._v(\"挂载阶段所做的主要工作是创建Vue实例并用其替换el选项对应的DOM元素，同时还要开启对模板中数据（状态）的监控，当数据（状态）发生变化时通知其依赖进行视图更新。\")]),t._v(\" \"),s(\"ol\",{attrs:{start:\"4\"}},[s(\"li\",[t._v(\"销毁阶段\")])]),t._v(\" \"),s(\"p\",[t._v(\"当调用了实例的$destroy方法之后，当前实例就进入了销毁阶段。将当前的Vue实例从其父级实例中删除，取消当前实例上的所有依赖追踪并且移除实例上的所有事件监听器。\")])])}),[],!1,null,null,null);e.default=l.exports}}]);","extractedComments":[]}